<!DOCTYPE html>
<html>
    
    <head>
    <meta content='width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;' name='viewport' />
    <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>
        </title>
        <link rel="stylesheet" href="style.css" type="text/css" />
        <script src="js/lib/jquery-1.8.0.min.js">
         		
        </script>
        <script src="js/lib/socket.io.js">
                		
        </script>
        <script src="js/lib/pomeloclient.js">
                		
        </script>
        <script src="js/client.js">
                		
        </script>
        <script src="js/pop.js">
                		
        </script>
        <script src="dropzone.js"></script>
    
<script type="text/javascript">
if(window.innerHeight > window.innerWidth){
    alert("Please use Landscape!");
}
var effect = null;
var bly=0
    loadedplayers = [];
    loadedplayersTarget = [];
    var rY=0;
    var precision = 'highp'
    var running = false;
    var fog;
    var blendMesh;
    var cubeMesh;
    var sky;
    var isFrameStepping;
    var clock;
    var gui;
    var particleGroup;
    var zt=0
    ld = false;
    var tcolor = '0.0';
</script>
<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
<script src='threex.min.js'></script>
<!--<script src='FlyControls.js'></script>-->
<script src='THREE.TargetCamera.js'></script>

<script src='SimplexNoise.js'></script>
<script src='threex.GeometryUtils.js'></script>
<script src='threex.terrain.js'></script>
<script src='threex.grass.js'></script>
<script src="dat.js"></script>
<script src="Mirror.js"></script>
<script src="Sky.js"></script>
<script src="WaterShader.js"></script>
<script src="Particles.js"></script>
<script src="nature-full.js"></script>

  <script src="StereoEffect.js"></script>
  <script src="DeviceOrientationControls.js"></script>
<script src="BlendCharacter.js"></script>
<script src="BlendCharacterGui.js"></script>
<script type="text/javascript" src="OBJLoader.js"></script>

<script src="sea3d.min.js"></script>
<style type="text/css">
    html, body {
    margin: 0;overflow:hidden;
    width: 668px !important;    height: 375px !important;
    }
    /*-------------------------
    SIMPLE RESET
--------------------------*/
*{
    margin:0;
    padding:0;
}
/*-------------------------
    BACKGROUND CSS
--------------------------*/
html {
    background-color: lightblue;
}
@media (orientation:landscape) {
    html > body {
        position: fixed;
        top: 0;
        width:100%;
        height: 375px !important;
    }
}

</style>
<script id="vertexShader" type="x-shader/x-vertex">
uniform sampler2D bumpTexture;
uniform float bumpScale;
varying float vAmount;
varying vec2 vUV;

void main() 
{ 
    vUV = uv;
    vec4 bumpData = texture2D( bumpTexture, uv );   
    vAmount = bumpData.r*0.7+0.1;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-vertex"> 
uniform sampler2D oceanTexture;
uniform sampler2D sandyTexture;
uniform sampler2D grassTexture;
uniform sampler2D rockyTexture;
uniform sampler2D snowyTexture;
varying vec2 vUV;
varying float vAmount;
varying float tcolor;
#ifdef USE_FOG

    uniform vec3 fogColor;

    #ifdef FOG_EXP2

        uniform float fogDensity;

    #else

        uniform float fogNear;
        uniform float fogFar;
    #endif

#endif

void main() 
{
    vec3 outgoingLight = vec3( 1.0 );
    vec4 water = (smoothstep(0.0, 0.1, vAmount) - smoothstep(0.04, 0.16, vAmount)) * texture2D( oceanTexture, vUV * 100.0 );
    vec4 sandy = (smoothstep(0.04, 0.16, vAmount) - smoothstep(0.18, 0.32, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );
    vec4 grass = (smoothstep(0.18, 0.32, vAmount) - smoothstep(0.65, 0.75, vAmount)) * texture2D( grassTexture, vUV * 20.0 );
    vec4 rocky = (smoothstep(0.65, 0.75, vAmount) - smoothstep(0.78, 0.82, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );
    vec4 snowy = (smoothstep(0.78, 0.82, vAmount) - smoothstep(0.85, 0.90, vAmount))                                   * texture2D( snowyTexture, vUV * 10.0 );

    vec4 snowy2 = ( smoothstep(0.85, 0.90, vAmount))                                   * texture2D( snowyTexture, vUV * 20.0 );
    float tcolor = 0.7;
    
#ifdef USE_FOG

    #ifdef USE_LOGDEPTHBUF_EXT

        float depth = gl_FragDepthEXT / gl_FragCoord.w;

    #else

        float depth = gl_FragCoord.z / gl_FragCoord.w;

    #endif

    #ifdef FOG_EXP2

        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );
        fogFactor = whiteCompliment( fogFactor );

    #else

        float fogFactor = smoothstep( fogNear, fogFar, depth );

    #endif
    
    outgoingLight = mix( outgoingLight, fogColor, fogFactor );
gl_FragColor = vec4(tcolor, tcolor, tcolor, 1.0) *(water + sandy + grass + rocky + snowy + snowy2) * outgoingLight.x; //, 1.0);

#endif
}  
</script>
 </head>
    
    <body style="overflow: hidden;background:black;font-family: Verdana,Geneva,sans-serif;overflow:hidden;margin:0;">
                <span style="font-size:8px;position:absolute;bottom:0px;left:0px;width:100%;"><center>&lt;/&gt; with &#10084; by mebyz (emmanuel.botros@gmail.com)</center></span>
        <script src="texgen.js"></script>
    <div class="container" >
  <div id="cloud-intro" class="wind">
      
        <div id="app">
            <div id="loginView"  style="display:none;">
                <div id="loginTitle">
                </div>
                <table>
                    <tr>
                        <td>
                            <input id="loginUser" type="text" placeholder="enter your name" /> 
                            <!--<input type="button" value="choose avatar" id="fu"/>-->
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <input name="channels" type="hidden" id="channelList" value="main"
                            />
                        </td>
                        <tr>
                            <td>
                                <span id="loading" style="display:none;">Connecting to game server ...</span>
                                <input id="login" type='button' class="button" value="Join !" />
                            </td>
                        </tr>
                </table>
                <div id="loginError">
                </div>

<canvas id="canvas1" width="256" height="256" style="z-index:-1000;position:absolute;top:0px;left:5px;"></canvas>
<canvas id="canvas2" width="256" height="256" style="z-index:-1000;position:absolute;top:0px;left:5px;"></canvas>
<canvas id="canvas3" width="256" height="256" style="z-index:-1000;position:absolute;top:0px;left:5px;"></canvas>
<canvas id="canvas4" width="256" height="256" style="z-index:-1000;position:absolute;top:0px;left:5px;"></canvas>
<canvas id="canvas5" width="256" height="256" style="z-index:-1000;position:absolute;top:0px;left:5px;"></canvas>

            </div>
            <div id="chatHistory" style="position:absolute;">

            </div>
<div id="3d" style="display:none;"></div>
    <div id="pos" style="position:absolute;top:0px;left:0px;color:white;"></div>
    <div id="pos2" style="position:absolute;top:20px;left:0px;color:white;"></div>

                  <div id="blocker"></div>
    <div id="instructions"></div>
             <script>
var VRSP=0;
var oka=function(s,score) {alert(s+' score:'+score)};

        var HEIGHTMAPSIZE = 16
        var MAXTILES = 40

        var MAP = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAP[i] = new Array(MAXTILES);
        }

        var MAPMESHES = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPMESHES[i] = new Array(MAXTILES);
        }
        var MAPU = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPU[i] = new Array(MAXTILES);
        }

        var MAPGRASS = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS[i] = new Array(MAXTILES);
        }
        var MAPGRASS2 = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS2[i] = new Array(MAXTILES);
        }
        var MAPGRASS3 = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS3[i] = new Array(MAXTILES);
        }
        var MAPGRASS4 = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS4[i] = new Array(MAXTILES);
        }

        var MAPOBSCACLES = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPOBSCACLES[i] = new Array(MAXTILES);
        }

        var MAPTREES = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPTREES[i] = new Array(MAXTILES);
        }
        var world = new Array(MAXTILES*HEIGHTMAPSIZE);
        for (var i = 0; i < MAXTILES*HEIGHTMAPSIZE; i++) {
            world[i] = new Array(MAXTILES*HEIGHTMAPSIZE);
        for (var j = 0; j < MAXTILES*HEIGHTMAPSIZE; j++) {
                    world[i][j] = 0;

        }}

        var okok = true;




            function onStartAnimation( event ) {

                var data = event.detail;

                blendMesh.stopAll();

                // the blend mesh will combine 1 or more animations
                for ( var i = 0; i < data.anims.length; ++i ) {

                    blendMesh.play(data.anims[i], data.weights[i]);

                }

                isFrameStepping = false;

            }

            function onStopAnimation( event ) {

                blendMesh.stopAll();
                isFrameStepping = false;

            }

            function onPauseAnimation( event ) {

                ( isFrameStepping ) ? blendMesh.unPauseAll(): blendMesh.pauseAll();

                isFrameStepping = false;

            }

            function onStepAnimation( event ) {

                blendMesh.unPauseAll();
                isFrameStepping = true;
                timeToStep = event.detail.stepSize;
            }

            function onWeightAnimation(event) {

                var data = event.detail;
                for ( var i = 0; i < data.anims.length; ++i ) {

                    blendMesh.applyWeight(data.anims[i], data.weights[i]);

                }

            }

            function onCrossfade(event) {

                var data = event.detail;

                blendMesh.stopAll();
                blendMesh.crossfade( data.from, data.to, data.time );

                isFrameStepping = false;

            }

            function onWarp( event ) {

                var data = event.detail;

                blendMesh.stopAll();
                blendMesh.warp( data.from, data.to, data.time );

                isFrameStepping = false;

            }


            function onLockCameraToggle( event ) {

                var shouldLock = event.detail.shouldLock;
                controls.enabled = !shouldLock;

            }

            function onShowSkeleton( event ) {

                var shouldShow = event.detail.shouldShow;
                blendMesh.showSkeleton( shouldShow );

            }

            function onShowModel( event ) {

                var shouldShow = event.detail.shouldShow;
                blendMesh.showModel( shouldShow );

            }

            function start() {
                $('.dg').hide()

                blendMesh.visible=false
                blendMesh.scale.x=0.1
                blendMesh.scale.y=0.1
                blendMesh.scale.z=0.1

                blendMesh.position.x=10000
                blendMesh.position.z=10000

                blendMesh.lookAt(new THREE.Vector3(100000,0,100000))

                blendMesh.rotation.y = Math.PI * -135 / 180;
                scene.add( blendMesh );

                blendMesh.animations[ 'idle' ].weight = 0;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 0;

                gui = new BlendCharacterGui(blendMesh.animations);

                blendMesh.play("idle", blendMesh.animations[ 'idle' ].weight);

settings = {
                            name: 'camp',
                            targetObject: blendMesh,
                            cameraPosition: new THREE.Vector3( 0, 30, 30 ),
                            fixed: false,
                            stiffness: .1
//                            matchRotation: !!(i % 3)
                        };
/*                settings = {
                            name: 'camp',
                            targetObject: blendMesh,
                            cameraPosition: new THREE.Vector3(
                                1 - Math.random() * 2 | 0,
                                Math.random() * 2 | 0,
                                5 + Math.random() * 5 | 0
                            ),
                            fixed: true,
                            matchRotation: !!(i % 3)
                        };*/
                   
                    // Add the box as a target object for the TargetCamera.
                    camera.addTarget( settings );
                    camera.setTarget('camp');
                                //dat.GUI.toggleHide()

                //isFrameStepping = false;
            }




        function initSky() {
            sky = new THREE.Sky();
            scene.add(sky.mesh);
            sunSphere = new THREE.Mesh(new THREE.SphereGeometry(20000, 30, 30),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: false
                }));
            sunSphere.position.y = -700000;
            sunSphere.visible = true;
            scene.add(sunSphere);

            var effectController = {
                turbidity: 10,
                reileigh: 1.5,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.8,
                luminance: 1,
                inclination: 0.49, // elevation / inclination
                azimuth: 0.25, // Facing front,
                sun: !true
            }

            function guiChanged() {
                var uniforms = sky.uniforms;
                uniforms.turbidity.value = effectController.turbidity;
                uniforms.reileigh.value = effectController.reileigh;
                uniforms.luminance.value = effectController.luminance;
                uniforms.mieCoefficient.value = effectController.mieCoefficient;
                uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

                var theta = Math.PI * (effectController.inclination - 0.5);

                scene.fog.color.r = 0.5 - effectController.inclination * 2
                scene.fog.color.g = 0.5 - effectController.inclination * 2
                scene.fog.color.b = 0.5 - effectController.inclination * 2

                var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

                sunSphere.position.x = distance * Math.cos(phi);
                sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);

                sunSphere.visible = effectController.sun;

                sky.uniforms.sunPosition.value.copy(sunSphere.position);

            }

            var gui2 = new dat.GUI();
            gui2.add(effectController, "turbidity", 1.0, 20.0, 0.1).onChange(guiChanged);
            gui2.add(effectController, "reileigh", 0.0, 4, 0.001).onChange(guiChanged);
            gui2.add(effectController, "mieCoefficient", 0.0, 0.1, 0.001).onChange(guiChanged);
            gui2.add(effectController, "mieDirectionalG", 0.0, 1, 0.001).onChange(guiChanged);
            gui2.add(effectController, "luminance", 0.0, 2).onChange(guiChanged);;
            gui2.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
            gui2.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
            gui2.add(effectController, "sun").onChange(guiChanged);

            guiChanged();
            $(".dg").hide()
            //camera.lookAt(sunSphere.position)


     var texture = loadImage('clouds001.png');

     particleGroup = new ShaderParticleGroup({
        texture: texture,
        maxAge: 100
    });

     emitter = new ShaderParticleEmitter({
        position: new THREE.Vector3(15000, 600, 15000),
        positionSpread: new THREE.Vector3(35000, 200, 35000),

        colorStart: new THREE.Color(0x000000),
        colorSpread: new THREE.Vector3(-1, -1, -1),
        colorEnd: new THREE.Color(0x000000),
        size: 100000,
        sizeSpread: 0,
        opacityStart: 0,
        opacityMiddle: 0.5,
        opacityEnd: 0,

        particlesPerSecond: 0.5,
    });

     particleGroup.addEmitter( emitter );
     scene.add( particleGroup.mesh );

        }
        var distance = 400000;
        var nature_models = [];
        var i = 0;
//        console.log(nature_)
        var n =nature_;//Array(nature_[0]);//,nature_[15],nature_[25],nature_[35],nature_[45]);//[{"obj":"models/trees/f_pinetree1/obj__pinet1.obj","png":"models/trees/f_pinetree1/pinet1.png"}]

        for (var index in n) {
            var fobj = '../' + n[index].obj;
            var ftext = '/' + n[index].png;
            console.log(ftext);
            loadTree(ftext, fobj, i++);
        }

        function loadTree(t, o, i) {
            var manager = new THREE.LoadingManager();
            manager.onProgress = function(item, loaded, total) {};
            var texture = new THREE.Texture();
            var onProgress = function(xhr) {};
            var onError = function(xhr) {};
            var loader = new THREE.ImageLoader(manager);
            loader.load(t, function(image) {
                texture.image = image;
                texture.needsUpdate = true;
            });
            var loader = new THREE.OBJLoader(manager);
            loader.load(o, function(object) {
                object.traverse(function(child) {
                    if (child instanceof THREE.Mesh) {
                        child.material.map = texture;
                        child.material.transparent = true;
                        child.material.alphaTest = 0.5;
                        child.material.side = THREE.DoubleSide;
                    }
                });
                //console.log(i+' '+t+' '+object.id)
                nature_models[i] = object;;
            }, onProgress, onError);
        }

        var loadImage = function(url) {
            return THREE.ImageUtils.loadTexture(url, null, function() {});
        }


ch = new Chromanin(256,'canvas3');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,155,155,155);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

        var oceanTexture = new THREE.Texture(canvas1) 
        oceanTexture.needsUpdate = true;
oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping;


ch = new Chromanin(256,'canvas2');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,146,85,24);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

ch = new Chromanin(256,'canvas1');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,40,85,2);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

        var sandyTexture = new THREE.Texture(canvas2) 
sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping;
        sandyTexture.needsUpdate = true;
//sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping;
//        var sandyTexture = new loadImage('sand-512.jpg');
//        sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping;

//        var grassTexture = new loadImage('grass-512.jpg');
//        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        var grassTexture = new THREE.Texture(canvas1) 
        grassTexture.needsUpdate = true;
grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;

        var rockyTexture = new THREE.Texture(canvas2) 
        rockyTexture.needsUpdate = true;
rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping;

//        var rockyTexture = new loadImage('rock-512.jpg');
//        rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping;

ch = new Chromanin(256,'canvas4');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,255,255,255);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

//        var oceanTexture = new loadImage('dirt-512.jpg');
//        oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping;
        var snowyTexture = new THREE.Texture(canvas1) 
        snowyTexture.needsUpdate = true;
snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping;

//        var snowyTexture = new loadImage('snow-512.jpg');
//        snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping;


        var TILES = 2

        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        var gmesh, water, hemiLight, light;
        var posgrass = [];
        var posgrass2 = [];
        var posgrass3 = [];
        var posgrass4 = [];
        var postrees = [];
        var controls;
        var controlsEnabled = false;
        var renderer = new THREE.WebGLRenderer({
            'precision': precision
        });
        renderer.setSize(    window.innerWidth, window.innerHeight);
        document.getElementById('3d').appendChild(renderer.domElement);

        effect = new THREE.StereoEffect( renderer );
                effect.eyeSeparation = 10;
                effect.setSize( 668, 375);
        var velocity = new THREE.Vector3();
        var onRenderFcts = [];
        var scene = new THREE.Scene();
        clock = new THREE.Clock();
        //scene.fog = new THREE.Fog(0x111111, 100, 1600);
        //    scene.fog.color.setHSL( 0.1, 0.1, 0.1 );

        scene.fog = new THREE.Fog(0x000000, 100, 3000);

        //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000000);
        var camera = new THREE.TargetCamera(45, 668 / 375, 0.01, 1000000);
        scene.add(camera);
        
        // RUN !
        moveForward = true;


        var onKeyDown = function(event) {

            switch (event.keyCode) {

                case 32: // up
                    summon()
                break;
                case 38: // up
                case 87: // w
                if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 0;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 1;

if (running ==false) {
                blendMesh.play("run", blendMesh.animations[ 'run' ].weight);
running=true;
            }}
                    moveForward = true;
                    break;

                case 37: // left
                case 65: // a
                    moveLeft = true;
                    break;

                case 40: // down
                case 83: // s
if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 0;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 1;
if (running ==false) {
                blendMesh.play("run", blendMesh.animations[ 'run' ].weight);
running=true;
            }
}
                    moveBackward = true;
                    break;

                case 39: // right
                case 68: // d
                    moveRight = true;
                    break;

                case 32: // space
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;

            }

        };

        var onKeyUp = function(event) {

            switch (event.keyCode) {

                case 38: // up
                case 87: // w
if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 1;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 0;
                blendMesh.play("idle", blendMesh.animations[ 'idle' ].weight);
running=false}
                    moveForward = false;
                    break;

                case 37: // left
                case 65: // a
                    moveLeft = false;
                    break;

                case 40: // down
                case 83: // s

if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 1;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 0;
                blendMesh.play("idle", blendMesh.animations[ 'idle' ].weight);
                running=false
            } 

                    moveBackward = false;
                    break;

                case 39: // right
                case 68: // d
                    moveRight = false;
                    break;

            }

        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

      
        (function() {
           
            light = new THREE.DirectionalLight('white', 0.1 * 2)
            light.position.set(-0.5, -0.5, -2)
            scene.add(light)
            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, .9);
            scene.add(hemiLight)

        })()

        var cube
        var heightMap, mesh, geometry, material;
        setTimeout(function() {
                ld = true
            }, 5000)
           
        initSky();
    

// listen for messages from the gui
              
               

        var parameters = {
            width: 10000,
            height: 10000,
            widthSegments: 500,
            heightSegments: 500,
            depth: 1500,
            param: 1,
            filterparam: 1
        }

        var waterNormals;

/*ch = new Chromanin(256,'canvas5');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,255,255,255);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();


        var waterNormals = new THREE.Texture(canvas5) 
        waterNormals.needsUpdate = true;
waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;*/
/*        waterNormals = new THREE.ImageUtils.loadTexture('images/waternormals.jpg');
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

        water = new THREE.Water(renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 1.0,
            fog: true,
            sunDirection: light.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        });
*/

        mirrorMesh = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(parameters.width, parameters.height),
            new THREE.MeshBasicMaterial({
                    color: 0x0066CC,
                    wireframe: false
                })
            //water.material
        );

        mirrorMesh.add(water);
        mirrorMesh.rotation.x = -Math.PI * 0.5;
        mirrorMesh.position.y = -200;
        mirrorMesh.position.x = 500;
        mirrorMesh.position.z = 500;
        mirrorMesh.scale.multiplyScalar(1)

        scene.add(mirrorMesh);

//        var worker = new Worker('/worker.js');
        
        function addTile(x, y, no) {

            if (no != true) {

                heightMap = THREEx.Terrain.allocateHeightMap(HEIGHTMAPSIZE, HEIGHTMAPSIZE)
                THREEx.Terrain.simplexHeightMap(heightMap, (HEIGHTMAPSIZE - 1) * x, (HEIGHTMAPSIZE - 1) * y)
                p = []
                p2 = []
                p3 = []
                p4 = []
                pt = []
                var ob = Array();
                geometry = THREEx.Terrain.heightMapToPlaneGeometry(heightMap, x, y, p, p2, p3, p4, pt, ob)
                gp = new THREEx.createGrassTufts(p, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS[x][y] = gp
                gp = new THREEx.createGrassTufts(p2, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS2[x][y] = gp
                gp = new THREEx.createGrassTufts(p3, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS3[x][y] = gp
                gp = new THREEx.createGrassTufts(p4, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS4[x][y] = gp

                for (var i = ob.length - 1; i >= 0; i--) {
                    for (var j = ob[i].length - 1; j >= 0; j--) {
                        if (ob[i][j]==1)
                        console.log ('addingobs :'+(x*HEIGHTMAPSIZE+i)+' '+(y*HEIGHTMAPSIZE+j))
                         world[x*HEIGHTMAPSIZE+i][y*HEIGHTMAPSIZE+j]=ob[i][j];
                }
            }

                MAPOBSCACLES[x][y] = ob

                MAPTREES[x][y] = [];

                for (var i = 0; i < pt.length; i++) {
                    var r = Math.round(Math.random()*nature_models.length);// i * x * y % nature_models.length; //Math.round(Math.random()*68)
                    if (nature_models[r] != undefined) {
                        var child = nature_models[r].clone();
                        child.name = "nature_" + i;
                        child.position.set(pt[i].x, pt[i].y-10, pt[i].z);
                        scene.add(child);
                        child.updateMatrixWorld(true);
                        MAPTREES[x][y].push(child);
                    }
                }


                THREEx.Terrain.heightMapToVertexColor(heightMap, geometry)

                var canvas = THREEx.Terrain.heightMapToCanvas(heightMap)

                document.body.appendChild(canvas)


                var texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                var customUniforms = {
                    fogDensity: {
                        type: "f",
                        value: 0.00025
                    },
                    fogColor: {
                        type: "c",
                        value: scene.fog.color
                    },
                    fogNear: {
                        type: "f",
                        value: scene.fog.near
                    },
                    fogFar: {
                        type: "f",
                        value: scene.fog.far
                    },
                    bumpTexture: {
                        type: "t",
                        value: texture
                    },
                    bumpScale: {
                        type: "f",
                        value: 1.0
                    },
                    tcolor: {
                        type: "f",
                        value: tcolor
                    },
                    oceanTexture: {
                        type: "t",
                        value: oceanTexture
                    },
                    sandyTexture: {
                        type: "t",
                        value: sandyTexture
                    },
                    grassTexture: {
                        type: "t",
                        value: grassTexture
                    },
                    rockyTexture: {
                        type: "t",
                        value: rockyTexture
                    },
                    snowyTexture: {
                        type: "t",
                        value: snowyTexture
                    },

                };

                var material = new THREE.ShaderMaterial({
                    fog: true,
                    uniforms: customUniforms,
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                });
                mesh = new THREE.Mesh(geometry, material);
                MAPU[x][y] = material

                scene.add(mesh);
                mesh.position.x = 1000 * x + 500
                mesh.position.z = 1000 * y + 500
                mesh.scale.z = 0.01

                mesh.rotateX(-Math.PI / 2)
                mesh.scale.multiplyScalar(1000)
                MAP[x][y] = heightMap;
                MAPMESHES[x][y] = mesh;

            } else {

                //geo = new THREEx.Terrain.PlaneGeometry( 1, 1,63, 63);
                //heightMap = null//THREEx.Terrain.allocateHeightMap(64, 64)
                //THREEx.Terrain.simplexHeightMap(heightMap,63*x,63*y)

                //worker.postMessage({
                //    x: x,
                //    y: y //,geo:geo,heightMap:heightMap
                //});

                MAP[x][y] = 1;
                MAPMESHES[x][y] = 1;

            }

        }


        onRenderFcts.push(function(delta, now) {

                camera.update();
particleGroup.tick(delta)            
zt += delta/500
z=zt
                var theta = Math.PI * ( z- 0.5);
                
                scene.fog.color.r = 0.5 - z * 2
                scene.fog.color.g = 0.5 - z * 2
                scene.fog.color.b = 0.5 - z * 2

                var phi = 2 * Math.PI * (0.25 - 0.5);

                sunSphere.position.x = distance * Math.cos(phi);
                sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);

                sky.uniforms.sunPosition.value.copy(sunSphere.position);
        
if (moveForward || moveBackward || moveLeft || moveRight  )
            if ( blendMesh && blendMesh.position != undefined) {
      
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                if (moveForward) velocity.z -= 20.0 * delta * 30;
                if (moveBackward) velocity.z += 20.0 * delta * 30;

 if (blendMesh.position.y < -210) velocity.z /=2 

            //    if (moveLeft) velocity.x -= 20.0 * delta * 15;
            //    if (moveRight) velocity.x += 20.0 * delta * 15;


     bly = 0
     if (moveLeft) bly = .05
     if (moveRight) bly = -.05

        //TURN !!
    bly = VRSP;
 blendMesh.rotation.y += bly

                blendMesh.translateZ(velocity.z * delta);
               blendMesh.translateX(velocity.x * delta);
               
      
                



            }
            
            if (blendMesh && blendMesh.position != undefined ) {
            cx = blendMesh.position.x % 1000;
            cz = blendMesh.position.z % 1000;




            tcx = Math.floor(blendMesh.position.x / 1000);
            tcz = Math.floor(blendMesh.position.z / 1000);
            
            
            var notremove = true
            var nearbytiles = [];

            preload = 1;


            if (ld == true) {


                for (var i = tcx - TILES / 2 - preload; i <= tcx + TILES / 2 + preload; i++) {
                    for (var j = tcz - TILES / 2 - preload; j <= tcz + TILES / 2 + preload; j++) {

                        if (i >= 0 && j >= 0)
                            nearbytiles.push(i + '_' + j);
                    }
                }
                //console.log(nearbytiles);
                for (var i = 0; i < MAXTILES; i++) {
                    for (var j = 0; j < MAXTILES; j++) {

                        if (nearbytiles.indexOf(i + '_' + j) < 0 && MAP[i][j] != undefined) {

                            if (notremove != false) {
                                MAPMESHES[i][j].visible = false
                                MAPGRASS[i][j].visible = false
                                MAPGRASS2[i][j].visible = false
                                MAPGRASS3[i][j].visible = false
                                MAPGRASS4[i][j].visible = false
                                for (var k = 0; k < MAPTREES[i][j].length; k++) {
                                    MAPTREES[i][j][k].visible = false
                                }

                            } else {
                                //              console.log('NEED TO DESTROY : '+i+'_'+j)
                                scene.remove(MAPMESHES[i][j]);
                                scene.remove(MAPGRASS[i][j])
                                scene.remove(MAPGRASS2[i][j])
                                scene.remove(MAPGRASS3[i][j])
                                scene.remove(MAPGRASS4[i][j])

                                for (var k = 0; k < MAPTREES[i][j].length; k++) {
                                    scene.remove(MAPTREES[i][j][k])
                                    MAPTREES[i][j][k] = null
                                }

                                MAPMESHES[i][j].geometry.dispose();
                                MAPMESHES[i][j].material.dispose();
                                MAPMESHES[i][j] = null
                                MAP[i][j] = null;


                            }
                        }

                        if (nearbytiles.indexOf(i + '_' + j) > -1 && MAP[i][j] != undefined) {

                            if (notremove != false) {
                                MAPMESHES[i][j].visible = true
                                MAPGRASS[i][j].visible = true
                                MAPGRASS2[i][j].visible = true
                                MAPGRASS3[i][j].visible = true
                                MAPGRASS4[i][j].visible = true
                                for (var k = 0; k < MAPTREES[i][j].length; k++) {
                                    MAPTREES[i][j][k].visible = true
                                }
                            }
                        }

                        if (nearbytiles.indexOf(i + '_' + j) > -1 && MAP[i][j] == undefined) {
                            //              console.log('NEED TO CREATE :'+i+'_'+j)
                            console.log('addtile : ' + i + '' + j)
                            addTile(i, j)
                        }

                    }
                }


            }
            if (blendMesh.position.x < 1 + 1 || blendMesh.position.z < 1 + 1
            )
                blendMesh.position.y = -216.4
            else {

                cx2 = cubeMesh.position.x % 1000;
                cz2 = cubeMesh.position.z % 1000;

                tcx2 = Math.floor(cubeMesh.position.x / 1000);
                tcz2 = Math.floor(cubeMesh.position.z / 1000);
                /*
                //CUBE
                if (cubeMesh.path[cubeMesh.p]) {
                if (cubeMesh.position.x<cubeMesh.path[cubeMesh.p][0]/16*1001) {
                    cubeMesh.position.x+=.01+cubeMesh.px
                    cubeMesh.px+=0.001;
                }
                //cubeMesh.position.x+=cubeMesh.px/5000;
                if (cubeMesh.px>0.05)
                cubeMesh.px-=0.0005;
                
                if (cubeMesh.position.z<cubeMesh.path[cubeMesh.p][1]/16*1001) {
                    cubeMesh.position.z+=.01+cubeMesh.pz
                    cubeMesh.pz+=0.001;
                } 

                if (cubeMesh.position.z<cubeMesh.path[cubeMesh.p][1]/16*1001) {
                    cubeMesh.position.z+=.01+cubeMesh.pz
                    cubeMesh.pz+=0.001;
                }

                if (cubeMesh.position.z>cubeMesh.path[cubeMesh.p][1]/16*1001) {
                    cubeMesh.position.z-=.01+cubeMesh.pz
                    cubeMesh.pz-=0.001;
                } 

                if (cubeMesh.position.z>cubeMesh.path[cubeMesh.p][1]/16*1001) {
                    cubeMesh.position.z-=.01+cubeMesh.pz
                    cubeMesh.pz-=0.001;
                }
                //cubeMesh.position.z+=cubeMesh.pz/5000;
                if (cubeMesh.pz>0.05)
                cubeMesh.pz-=0.0005;

                if (cubeMesh.position.x==cubeMesh.path[cubeMesh.p][0]/16*1001 &&                cubeMesh.position.z==cubeMesh.path[cubeMesh.p][1]/16*1001)
                    cubeMesh.p++;
                }

                
//                cubeMesh.position.x+=0.1
*/
if (cubeMesh && cubeMesh.path && cubeMesh.path[cubeMesh.p]) {

cubeMesh.lookAt(new THREE.Vector3(cubeMesh.path[cubeMesh.p][0]/16*1001,cubeMesh.position.y,cubeMesh.path[cubeMesh.p][1]/16*1001))
cubeMesh.translateZ(0.5)
cubeMesh.moving=true;

                 if (Math.abs(cubeMesh.position.x-cubeMesh.path[cubeMesh.p][0]/16*1001)<10 && Math.abs(cubeMesh.position.z>=cubeMesh.path[cubeMesh.p][1]/16*1001)<10) {
                    if (cubeMesh.path[cubeMesh.p+1])
                        cubeMesh.lookAt(new THREE.Vector3(                        cubeMesh.path[cubeMesh.p+1][0],cubeMesh.position.y, cubeMesh.path[cubeMesh.p+1][1]))
                    cubeMesh.p++;

    cubeMesh.animations["idle"].isPlaying=false;
                        cubeMesh.play("walk")
                 } 

} else {
    cubeMesh.animations["walk"].isPlaying=false;
cubeMesh.play("idle")

cubeMesh.moving=false;
// GO BACK
if (0 && cubeMesh.p == cubeMesh.path.length && cubeMesh.back==false) {

    cubeMesh.back=true
                cubeMesh.p=0;
                cubeMesh.px=0;
                cubeMesh.pz=0;
                t=findPath(world,[Math.round(cubeMesh.position.x/1001*16),Math.round(cubeMesh.position.z/1001*16)],[160,160]);
                cubeMesh.path=t
                }
            }


                
                cubeMesh.position.y = THREEx.Terrain.planeToHeightMapCoords(MAP[tcx2][tcz2], MAPMESHES[tcx2][tcz2], cx2, cz2) 
        
                //CUBE

                if (ld == true) blendMesh.position.y = THREEx.Terrain.planeToHeightMapCoords(MAP[tcx][tcz], MAPMESHES[tcx][tcz], cx, cz) 
                if (blendMesh.position.y < -216.4) blendMesh.position.y = -216.4
            }

            mirrorMesh.position.x = blendMesh.position.x;
            mirrorMesh.position.z = blendMesh.position.z;
//            $('#pos').html(Math.round(blendMesh.position.x) + ' ' + Math.round(blendMesh.position.y) + ' ' + Math.round(blendMesh.position.z))


}
       })

        onRenderFcts.push(function() {
            //water.material.uniforms.time.value += 1.0 / 60.0;

            //water.render();

            effect.render(scene, camera);
        })
        var lastTimeMsec = null
        requestAnimationFrame(function animate(nowMsec) {
            if (okok == true) {
if (gui != undefined) {
                     var scale = gui.getTimeScale();
                var delta = clock.getDelta();
                var stepSize = (!isFrameStepping) ? delta * scale: timeToStep;

                // modify blend weights
                if (blendMesh.skeletonHelper)
                blendMesh.update( stepSize );
                gui.update();
                THREE.AnimationHandler.update( stepSize );

}

                requestAnimationFrame(animate);
                lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
                var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
                lastTimeMsec = nowMsec
                onRenderFcts.forEach(function(onRenderFct) {
                    onRenderFct(deltaMsec / 1000, nowMsec / 1000)
                })
            }
        })

/*
     if (window.DeviceOrientationEvent) {
        // Listen for the deviceorientation event and handle the raw data
        window.addEventListener('deviceorientation', function(eventData) {
          // gamma is the left-to-right tilt in degrees, where right is positive
          var tiltLR = eventData.gamma;
          
          // beta is the front-to-back tilt in degrees, where front is positive
          var tiltFB = eventData.beta;
          
          // alpha is the compass direction the device is facing in degrees
          var dir = eventData.alpha
          
          // call our orientation event handler
          deviceOrientationHandler(tiltLR, tiltFB, dir);
          }, false);
      } else {
        document.getElementById("doEvent").innerHTML = "Not supported on your device or browser.  Sorry."
      }
    
  
    function deviceOrientationHandler(tiltLR, tiltFB, dir) {
        if (settings!="undefined") {
        settings.cameraPosition.y =50+tiltLR;
        settings.cameraPosition.x =tiltFB;
        }
    }*/

    if (!window.DeviceOrientationEvent) {
            //document.getElementById('do-unsupported').classList.remove('hidden');
         } else {
            //document.getElementById('do-info').classList.remove('hidden');
 
            window.addEventListener('deviceorientation', function(event) {
//               document.getElementById('cube').style.webkitTransform =

        settings.cameraPosition.x =2*event.beta;            
        settings.cameraPosition.y =90-event.gamma*2;
VRSP=event.beta/500;
//        settings.cameraPosition.z =event.alpha;

//              alert(   'rotateX(' + event.beta + 'deg) ' +   'rotateY(' + event.gamma + 'deg) ' + 'rotateZ(' + event.alpha + 'deg)');
 
  /*             document.getElementById('beta').innerHTML = Math.round(event.beta);
               document.getElementById('gamma').innerHTML = Math.round(event.gamma);
               document.getElementById('alpha').innerHTML = Math.round(event.alpha);
               document.getElementById('is-absolute').innerHTML = event.absolute ? "true" : "false";*/
            });
         }
 
         if (!window.DeviceMotionEvent) {
  //          document.getElementById('dm-unsupported').classList.remove('hidden');
         } else {
//            document.getElementById('dm-info').classList.remove('hidden');
 
            window.addEventListener('devicemotion', function(event) {
/*               document.getElementById('acceleration-x').innerHTML = Math.round(event.acceleration.x);
               document.getElementById('acceleration-y').innerHTML = Math.round(event.acceleration.y);
               document.getElementById('acceleration-z').innerHTML = Math.round(event.acceleration.z);
 
               document.getElementById('acceleration-including-gravity-x').innerHTML =
                       Math.round(event.accelerationIncludingGravity.x);
               document.getElementById('acceleration-including-gravity-y').innerHTML =
                       Math.round(event.accelerationIncludingGravity.y);
               document.getElementById('acceleration-including-gravity-z').innerHTML =
                       Math.round(event.accelerationIncludingGravity.z);
 
               document.getElementById('rotation-rate-beta').innerHTML = Math.round(event.rotationRate.beta);
               document.getElementById('rotation-rate-gamma').innerHTML = Math.round(event.rotationRate.gamma);
               document.getElementById('rotation-rate-alpha').innerHTML = Math.round(event.rotationRate.alpha);
 
               document.getElementById('interval').innerHTML = event.interval;*/
            });
         }
 
         if (!('oncompassneedscalibration' in window)) {
            //document.getElementById('cnc-unsupported').classList.remove('hidden');
         } else {
            window.addEventListener('compassneedscalibration', function(event) {
               alert('Compass needs calibrating! Wave your device in a figure-eight motion');
            });
         }

  var onMouseMove = function ( event ) {

    var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
    var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
  
  rY=event.movementX/500
  rX=-event.clientY/30+20

    if (blendMesh && blendMesh.position !=undefined) {
          
    //$('#pos2').html(rX)
      blendMesh.rotation.y -= Math.PI * rY

      settings.cameraPosition.y = -rX*3+35

      settings.cameraPosition.z = 30-rX*3
     
    }

  };

function summon(){
    cubeMesh.animations["idle"].isPlaying=false;
                cubeMesh.play("walk")

                cubeMesh.p=0;
                cubeMesh.px=0;
                cubeMesh.pz=0;
                cubeMesh.back=true;

                t=findPath(world,[Math.round(cubeMesh.position.x/1001*16),Math.round(cubeMesh.position.z/1001*16)],[Math.round(blendMesh.position.x/1001*16),Math.round(blendMesh.position.z/1001*16)]);
                cubeMesh.path=t//t.reverse().concat(s)
            }
function goto(x,z){
                cubeMesh.p=0;
                cubeMesh.px=0;
                cubeMesh.pz=0;
                cubeMesh.back=false;

                t=findPath(world,[160,160],[Math.round(x/1001*16),Math.round(z/1001*16)]);
                cubeMesh.path=t//t.reverse().concat(s)
            }
// world is a 2d array of integers (eg world[10][15] = 0)
// pathStart and pathEnd are arrays like [5,10]
function findPath(world, pathStart, pathEnd)
{
    // shortcuts for speed
    var abs = Math.abs;
    var max = Math.max;
    var pow = Math.pow;
    var sqrt = Math.sqrt;

    // the world data are integers:
    // anything higher than this number is considered blocked
    // this is handy is you use numbered sprites, more than one
    // of which is walkable road, grass, mud, etc
    var maxWalkableTileNum = 0;

    // keep track of the world dimensions
    // Note that this A-star implementation expects the world array to be square: 
    // it must have equal height and width. If your game world is rectangular, 
    // just fill the array with dummy values to pad the empty space.
    var worldWidth = world[0].length;
    var worldHeight = world.length;
    var worldSize = worldWidth * worldHeight;

    // which heuristic should we use?
    // default: no diagonals (Manhattan)
var distanceFunction = EuclideanDistance;
    var findNeighbours = DiagonalNeighbours;

    /*

    // alternate heuristics, depending on your game:

    // diagonals allowed but no sqeezing through cracks:
    var distanceFunction = DiagonalDistance;
    var findNeighbours = DiagonalNeighbours;

    // diagonals and squeezing through cracks allowed:
    var distanceFunction = DiagonalDistance;
    var findNeighbours = DiagonalNeighboursFree;

    // euclidean but no squeezing through cracks:
    var distanceFunction = EuclideanDistance;
    var findNeighbours = DiagonalNeighbours;

    // euclidean and squeezing through cracks allowed:
    var distanceFunction = EuclideanDistance;
    var findNeighbours = DiagonalNeighboursFree;

    */

    // distanceFunction functions
    // these return how far away a point is to another

    function ManhattanDistance(Point, Goal)
    {   // linear movement - no diagonals - just cardinal directions (NSEW)
        return abs(Point.x - Goal.x) + abs(Point.y - Goal.y);
    }

    function DiagonalDistance(Point, Goal)
    {   // diagonal movement - assumes diag dist is 1, same as cardinals
        return max(abs(Point.x - Goal.x), abs(Point.y - Goal.y));
    }

    function EuclideanDistance(Point, Goal)
    {   // diagonals are considered a little farther than cardinal directions
        // diagonal movement using Euclide (AC = sqrt(AB^2 + BC^2))
        // where AB = x2 - x1 and BC = y2 - y1 and AC will be [x3, y3]
        return sqrt(pow(Point.x - Goal.x, 2) + pow(Point.y - Goal.y, 2));
    }

    // Neighbours functions, used by findNeighbours function
    // to locate adjacent available cells that aren't blocked

    // Returns every available North, South, East or West
    // cell that is empty. No diagonals,
    // unless distanceFunction function is not Manhattan
    function Neighbours(x, y)
    {
        var N = y - 1,
        S = y + 1,
        E = x + 1,
        W = x - 1,
        myN = N > -1 && canWalkHere(x, N),
        myS = S < worldHeight && canWalkHere(x, S),
        myE = E < worldWidth && canWalkHere(E, y),
        myW = W > -1 && canWalkHere(W, y),
        result = [];
        if(myN)
        result.push({x:x, y:N});
        if(myE)
        result.push({x:E, y:y});
        if(myS)
        result.push({x:x, y:S});
        if(myW)
        result.push({x:W, y:y});
        findNeighbours(myN, myS, myE, myW, N, S, E, W, result);
        return result;
    }

    // returns every available North East, South East,
    // South West or North West cell - no squeezing through
    // "cracks" between two diagonals
    function DiagonalNeighbours(myN, myS, myE, myW, N, S, E, W, result)
    {
        if(myN)
        {
            if(myE && canWalkHere(E, N))
            result.push({x:E, y:N});
            if(myW && canWalkHere(W, N))
            result.push({x:W, y:N});
        }
        if(myS)
        {
            if(myE && canWalkHere(E, S))
            result.push({x:E, y:S});
            if(myW && canWalkHere(W, S))
            result.push({x:W, y:S});
        }
    }

    // returns every available North East, South East,
    // South West or North West cell including the times that
    // you would be squeezing through a "crack"
    function DiagonalNeighboursFree(myN, myS, myE, myW, N, S, E, W, result)
    {
        myN = N > -1;
        myS = S < worldHeight;
        myE = E < worldWidth;
        myW = W > -1;
        if(myE)
        {
            if(myN && canWalkHere(E, N))
            result.push({x:E, y:N});
            if(myS && canWalkHere(E, S))
            result.push({x:E, y:S});
        }
        if(myW)
        {
            if(myN && canWalkHere(W, N))
            result.push({x:W, y:N});
            if(myS && canWalkHere(W, S))
            result.push({x:W, y:S});
        }
    }

    // returns boolean value (world cell is available and open)
    function canWalkHere(x, y)
    {
        return ((world[x] != null) &&
            (world[x][y] != null) &&
            (world[x][y] <= maxWalkableTileNum));
    };

    // Node function, returns a new object with Node properties
    // Used in the calculatePath function to store route costs, etc.
    function Node(Parent, Point)
    {
        var newNode = {
            // pointer to another Node object
            Parent:Parent,
            // array index of this Node in the world linear array
            value:Point.x + (Point.y * worldWidth),
            // the location coordinates of this Node
            x:Point.x,
            y:Point.y,
            // the heuristic estimated cost
            // of an entire path using this node
            f:0,
            // the distanceFunction cost to get
            // from the starting point to this node
            g:0
        };

        return newNode;
    }

    // Path function, executes AStar algorithm operations
    function calculatePath()
    {
        // create Nodes from the Start and End x,y coordinates
        var mypathStart = Node(null, {x:pathStart[0], y:pathStart[1]});
        var mypathEnd = Node(null, {x:pathEnd[0], y:pathEnd[1]});
        // create an array that will contain all world cells
        var AStar = new Array(worldSize);
        // list of currently open Nodes
        var Open = [mypathStart];
        // list of closed Nodes
        var Closed = [];
        // list of the final output array
        var result = [];
        // reference to a Node (that is nearby)
        var myNeighbours;
        // reference to a Node (that we are considering now)
        var myNode;
        // reference to a Node (that starts a path in question)
        var myPath;
        // temp integer variables used in the calculations
        var length, max, min, i, j;
        // iterate through the open list until none are left
        while(length = Open.length)
        {
            max = worldSize;
            min = -1;
            for(i = 0; i < length; i++)
            {
                if(Open[i].f < max)
                {
                    max = Open[i].f;
                    min = i;
                }
            }
            // grab the next node and remove it from Open array
            myNode = Open.splice(min, 1)[0];
            // is it the destination node?
            if(myNode.value === mypathEnd.value)
            {
                myPath = Closed[Closed.push(myNode) - 1];
                do
                {
                    result.push([myPath.x, myPath.y]);
                }
                while (myPath = myPath.Parent);
                // clear the working arrays
                AStar = Closed = Open = [];
                // we want to return start to finish
                result.reverse();
            }
            else // not the destination
            {
                // find which nearby nodes are walkable
                myNeighbours = Neighbours(myNode.x, myNode.y);
                // test each one that hasn't been tried already
                for(i = 0, j = myNeighbours.length; i < j; i++)
                {
                    myPath = Node(myNode, myNeighbours[i]);
                    if (!AStar[myPath.value])
                    {
                        // estimated cost of this particular route so far
                        myPath.g = myNode.g + distanceFunction(myNeighbours[i], myNode);
                        // estimated cost of entire guessed route to the destination
                        myPath.f = myPath.g + distanceFunction(myNeighbours[i], mypathEnd);
                        // remember this new path for testing above
                        Open.push(myPath);
                        // mark this node in the world graph as visited
                        AStar[myPath.value] = true;
                    }
                }
                // remember this route as having no more untested options
                Closed.push(myNode);
            }
        } // keep iterating until the Open list is empty
        return result;
    }

    // actually calculate the a-star path!
    // this returns an array of coordinates
    // that is empty if no path is possible
    return calculatePath();

} // end of findPath() function

  document.addEventListener( 'mousemove', onMouseMove, false );
    </script>
<!--            <div id="toolbar" style="display:none;">
                <input tabindex="1" type="text" id="entry" />
            </div>-->
        </div>
        <div id="pop">
            <div id="popHead">
                <a id="popClose" title="close">Close</a>
                <h2>
                    Tip
                </h2>
            </div>
            <div id="popContent">
                <dl>
                    <dd id="popIntro">
                    </dd>
                </dl>
                <p id="popMore">
                    No Tip Again
                </p>
            </div>
        </div>
  </div>
</div>
          <script type="text/javascript">
          //var myDropzone = new Dropzone("#fu", { url: "/file-upload"});
          var mAvatar = '/images/waternormals.jpg';
          /*myDropzone.on("complete", function(file) {

          mAvatar="/uploads/"+file.name;
   $("#fu").hide().before("<div style='overflow:hidden;'><img id='avatar' style='margin:5px;border:1px dotted black;' width='256' src='/uploads/"+file.name+"'/></div>");
  }
);*/
</script>
    </body>

</html>
