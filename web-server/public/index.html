<!DOCTYPE html>
<html>
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>
            MelonIsland
        </title>
        <link rel="stylesheet" href="style.css" type="text/css" />
        <script src="js/lib/jquery-1.8.0.min.js">
         		
        </script>
        <script src="js/lib/socket.io.js">
                		
        </script>
        <script src="js/lib/pomeloclient.js">
                		
        </script>
        <script src="js/client.js">
                		
        </script>
        <script src="js/pop.js">
                		
        </script>

<script type="text/javascript">
var bly=0
    loadedplayers = [];
    loadedplayersTarget = [];
    var rY=0;
    var precision = 'lowp'
    var running = false;
    var fog;
    var blendMesh;
    var sky;
    var isFrameStepping;
    var clock;
    var gui;
    var particleGroup;
    var zt=0
    ld = false;
    var tcolor = '0.0';
</script>
<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
<script src='threex.min.js'></script>
<!--<script src='FlyControls.js'></script>-->
<script src='THREE.TargetCamera.js'></script>

<script src='SimplexNoise.js'></script>
<script src='threex.GeometryUtils.js'></script>
<script src='threex.terrain.js'></script>
<script src='threex.grass.js'></script>
<script src="dat.js"></script>
<script src="Mirror.js"></script>
<script src="Sky.js"></script>
<script src="WaterShader.js"></script>
<script src="Particles.js"></script>
<!--<script src="nature.js"></script>-->

<script src="BlendCharacter.js"></script>
<script src="BlendCharacterGui.js"></script>
<script type="text/javascript" src="OBJLoader.js"></script>

   
<script id="vertexShader" type="x-shader/x-vertex">
uniform sampler2D bumpTexture;
uniform float bumpScale;
varying float vAmount;
varying vec2 vUV;

void main() 
{ 
    vUV = uv;
    vec4 bumpData = texture2D( bumpTexture, uv );   
    vAmount = bumpData.r*0.7+0.1;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-vertex"> 
uniform sampler2D oceanTexture;
uniform sampler2D sandyTexture;
uniform sampler2D grassTexture;
uniform sampler2D rockyTexture;
uniform sampler2D snowyTexture;
varying vec2 vUV;
varying float vAmount;
varying float tcolor;
#ifdef USE_FOG

    uniform vec3 fogColor;

    #ifdef FOG_EXP2

        uniform float fogDensity;

    #else

        uniform float fogNear;
        uniform float fogFar;
    #endif

#endif

void main() 
{
    vec3 outgoingLight = vec3( 1.0 );
    vec4 water = (smoothstep(0.0, 0.1, vAmount) - smoothstep(0.04, 0.16, vAmount)) * texture2D( oceanTexture, vUV * 100.0 );
    vec4 sandy = (smoothstep(0.04, 0.16, vAmount) - smoothstep(0.18, 0.32, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );
    vec4 grass = (smoothstep(0.18, 0.32, vAmount) - smoothstep(0.65, 0.75, vAmount)) * texture2D( grassTexture, vUV * 20.0 );
    vec4 rocky = (smoothstep(0.65, 0.75, vAmount) - smoothstep(0.78, 0.82, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );
    vec4 snowy = (smoothstep(0.78, 0.82, vAmount) - smoothstep(0.85, 0.90, vAmount))                                   * texture2D( snowyTexture, vUV * 10.0 );

    vec4 snowy2 = ( smoothstep(0.85, 0.90, vAmount))                                   * texture2D( snowyTexture, vUV * 20.0 );
    float tcolor = 0.5;
    
#ifdef USE_FOG

    #ifdef USE_LOGDEPTHBUF_EXT

        float depth = gl_FragDepthEXT / gl_FragCoord.w;

    #else

        float depth = gl_FragCoord.z / gl_FragCoord.w;

    #endif

    #ifdef FOG_EXP2

        float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );
        fogFactor = whiteCompliment( fogFactor );

    #else

        float fogFactor = smoothstep( fogNear, fogFar, depth );

    #endif
    
    outgoingLight = mix( outgoingLight, fogColor, fogFactor );
gl_FragColor = vec4(tcolor, tcolor, tcolor, 1.0) *(water + sandy + grass + rocky + snowy + snowy2) * outgoingLight.x; //, 1.0);

#endif
}  
</script>
 </head>
    
    <body style="overflow: hidden;background:black;">
        <script src="texgen.js"></script>
    <div class="container">
  <div id="cloud-intro" class="wind">
      
        <div id="app">
            <div id="loginView"  style="display:none;">
                <div id="loginTitle">
                    MelonIsland
                </div>
                <table>
                    <tr>
                        <td>
                            <input id="loginUser" type="text" placeholder="enter your name" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <input name="channels" type="hidden" id="channelList" value="main"
                            />
                        </td>
                        <tr>
                            <td>
                                <span id="loading" style="display:none;">Connecting to game server ...</span>
                                <br/>
                                <input id="login" type='button' class="button" value="Join game !" />
                            </td>
                        </tr>
                </table>
                <div id="loginError">
                </div>

<canvas id="canvas1" width="256" height="256" style="position:absolute;left:5000px;"></canvas>
<canvas id="canvas2" width="256" height="256" style="position:absolute;left:5000px;"></canvas>
<canvas id="canvas3" width="256" height="256" style="position:absolute;left:5000px;"></canvas>
<canvas id="canvas4" width="256" height="256" style="position:absolute;left:5000px;"></canvas>
<canvas id="canvas5" width="256" height="256" style="position:absolute;left:5000px;"></canvas>
                <span style="position:absolute;bottom:0px;left:0px;width:100%;"><center>&lt;/&gt; with &#10084; by emmanuel.botros@gmail.com</center></span>
            </div>
            <div id="chatHistory" style="position:absolute;">

            </div>
<div id="3d" style="width:100%;height:100%;display:none;"></div>
    <div id="pos" style="position:absolute;top:0px;left:0px;color:white;"></div>
    <div id="pos2" style="position:absolute;top:20px;left:0px;color:white;"></div>

                  <div id="blocker"></div>
    <div id="instructions"></div>
             <script>
        var HEIGHTMAPSIZE = 16
        var MAXTILES = 40

        var MAP = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAP[i] = new Array(MAXTILES);
        }

        var MAPMESHES = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPMESHES[i] = new Array(MAXTILES);
        }
        var MAPU = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPU[i] = new Array(MAXTILES);
        }

        var MAPGRASS = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS[i] = new Array(MAXTILES);
        }
        var MAPGRASS2 = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS2[i] = new Array(MAXTILES);
        }
        var MAPGRASS3 = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS3[i] = new Array(MAXTILES);
        }
        var MAPGRASS4 = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPGRASS4[i] = new Array(MAXTILES);
        }
        var MAPTREES = new Array(MAXTILES);
        for (var i = 0; i < MAXTILES; i++) {
            MAPTREES[i] = new Array(MAXTILES);
        }

        var okok = true;




            function onStartAnimation( event ) {

                var data = event.detail;

                blendMesh.stopAll();

                // the blend mesh will combine 1 or more animations
                for ( var i = 0; i < data.anims.length; ++i ) {

                    blendMesh.play(data.anims[i], data.weights[i]);

                }

                isFrameStepping = false;

            }

            function onStopAnimation( event ) {

                blendMesh.stopAll();
                isFrameStepping = false;

            }

            function onPauseAnimation( event ) {

                ( isFrameStepping ) ? blendMesh.unPauseAll(): blendMesh.pauseAll();

                isFrameStepping = false;

            }

            function onStepAnimation( event ) {

                blendMesh.unPauseAll();
                isFrameStepping = true;
                timeToStep = event.detail.stepSize;
            }

            function onWeightAnimation(event) {

                var data = event.detail;
                for ( var i = 0; i < data.anims.length; ++i ) {

                    blendMesh.applyWeight(data.anims[i], data.weights[i]);

                }

            }

            function onCrossfade(event) {

                var data = event.detail;

                blendMesh.stopAll();
                blendMesh.crossfade( data.from, data.to, data.time );

                isFrameStepping = false;

            }

            function onWarp( event ) {

                var data = event.detail;

                blendMesh.stopAll();
                blendMesh.warp( data.from, data.to, data.time );

                isFrameStepping = false;

            }


            function onLockCameraToggle( event ) {

                var shouldLock = event.detail.shouldLock;
                controls.enabled = !shouldLock;

            }

            function onShowSkeleton( event ) {

                var shouldShow = event.detail.shouldShow;
                blendMesh.showSkeleton( shouldShow );

            }

            function onShowModel( event ) {

                var shouldShow = event.detail.shouldShow;
                blendMesh.showModel( shouldShow );

            }

            function start() {
                $('.dg').hide()
                blendMesh.scale.x=0.1
                blendMesh.scale.y=0.1
                blendMesh.scale.z=0.1

                blendMesh.position.x=10000
                blendMesh.position.z=10000

                blendMesh.lookAt(new THREE.Vector3(100000,0,100000))

                blendMesh.rotation.y = Math.PI * -135 / 180;
                scene.add( blendMesh );

                blendMesh.animations[ 'idle' ].weight = 1;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 1;

                gui = new BlendCharacterGui(blendMesh.animations);

                blendMesh.play("idle", blendMesh.animations[ 'idle' ].weight);

settings = {
                            name: 'camp',
                            targetObject: blendMesh,
                            cameraPosition: new THREE.Vector3( 0, 30, 30 ),
                            fixed: false,
                            stiffness: .1
//                            matchRotation: !!(i % 3)
                        };
/*                settings = {
                            name: 'camp',
                            targetObject: blendMesh,
                            cameraPosition: new THREE.Vector3(
                                1 - Math.random() * 2 | 0,
                                Math.random() * 2 | 0,
                                5 + Math.random() * 5 | 0
                            ),
                            fixed: true,
                            matchRotation: !!(i % 3)
                        };*/
                   
                    // Add the box as a target object for the TargetCamera.
                    camera.addTarget( settings );
                    camera.setTarget('camp');
                                //dat.GUI.toggleHide()

                //isFrameStepping = false;
            }




        function initSky() {
            sky = new THREE.Sky();
            scene.add(sky.mesh);
            sunSphere = new THREE.Mesh(new THREE.SphereGeometry(20000, 30, 30),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: false
                }));
            sunSphere.position.y = -700000;
            sunSphere.visible = true;
            scene.add(sunSphere);

            var effectController = {
                turbidity: 10,
                reileigh: 1.5,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.8,
                luminance: 1,
                inclination: 0.49, // elevation / inclination
                azimuth: 0.25, // Facing front,
                sun: !true
            }

            function guiChanged() {
                var uniforms = sky.uniforms;
                uniforms.turbidity.value = effectController.turbidity;
                uniforms.reileigh.value = effectController.reileigh;
                uniforms.luminance.value = effectController.luminance;
                uniforms.mieCoefficient.value = effectController.mieCoefficient;
                uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

                var theta = Math.PI * (effectController.inclination - 0.5);

                scene.fog.color.r = 0.5 - effectController.inclination * 2
                scene.fog.color.g = 0.5 - effectController.inclination * 2
                scene.fog.color.b = 0.5 - effectController.inclination * 2

                var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

                sunSphere.position.x = distance * Math.cos(phi);
                sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);

                sunSphere.visible = effectController.sun;

                sky.uniforms.sunPosition.value.copy(sunSphere.position);

            }

            var gui2 = new dat.GUI();
            gui2.add(effectController, "turbidity", 1.0, 20.0, 0.1).onChange(guiChanged);
            gui2.add(effectController, "reileigh", 0.0, 4, 0.001).onChange(guiChanged);
            gui2.add(effectController, "mieCoefficient", 0.0, 0.1, 0.001).onChange(guiChanged);
            gui2.add(effectController, "mieDirectionalG", 0.0, 1, 0.001).onChange(guiChanged);
            gui2.add(effectController, "luminance", 0.0, 2).onChange(guiChanged);;
            gui2.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
            gui2.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
            gui2.add(effectController, "sun").onChange(guiChanged);

            guiChanged();
            //camera.lookAt(sunSphere.position)


     var texture = loadImage('clouds001.png');

     particleGroup = new ShaderParticleGroup({
        texture: texture,
        maxAge: 100
    });

     emitter = new ShaderParticleEmitter({
        position: new THREE.Vector3(15000, 600, 15000),
        positionSpread: new THREE.Vector3(35000, 200, 35000),

        colorStart: new THREE.Color(0x000000),
        colorSpread: new THREE.Vector3(-1, -1, -1),
        colorEnd: new THREE.Color(0x000000),
        size: 100000,
        sizeSpread: 0,
        opacityStart: 0,
        opacityMiddle: 0.5,
        opacityEnd: 0,

        particlesPerSecond: 3,
    });

     particleGroup.addEmitter( emitter );
     scene.add( particleGroup.mesh );

        }
        var distance = 400000;
        var nature_models = [];
        var i = 0;
//        console.log(nature_)
        var n =[{"obj":"models/trees/f_pinetree1/obj__pinet1.obj","png":"models/trees/f_pinetree1/pinet1.png"}]

        for (var index in n) {
            var fobj = '../' + n[index].obj;
            var ftext = '/' + n[index].png;
            console.log(ftext);
            loadTree(ftext, fobj, i++);
        }

        function loadTree(t, o, i) {
            var manager = new THREE.LoadingManager();
            manager.onProgress = function(item, loaded, total) {};
            var texture = new THREE.Texture();
            var onProgress = function(xhr) {};
            var onError = function(xhr) {};
            var loader = new THREE.ImageLoader(manager);
            loader.load(t, function(image) {
                texture.image = image;
                texture.needsUpdate = true;
            });
            var loader = new THREE.OBJLoader(manager);
            loader.load(o, function(object) {
                object.traverse(function(child) {
                    if (child instanceof THREE.Mesh) {
                        child.material.map = texture;
                        child.material.transparent = true;
                        child.material.alphaTest = 0.5;
                        child.material.side = THREE.DoubleSide;
                    }
                });
                //console.log(i+' '+t+' '+object.id)
                nature_models[i] = object;;
            }, onProgress, onError);
        }

        var loadImage = function(url) {
            return THREE.ImageUtils.loadTexture(url, null, function() {});
        }


ch = new Chromanin(256,'canvas3');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,155,155,155);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

        var oceanTexture = new THREE.Texture(canvas1) 
        oceanTexture.needsUpdate = true;
oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping;


ch = new Chromanin(256,'canvas2');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,146,85,24);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

ch = new Chromanin(256,'canvas1');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,40,85,2);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

        var sandyTexture = new THREE.Texture(canvas2) 
        sandyTexture.needsUpdate = true;
//sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping;
//        var sandyTexture = new loadImage('sand-512.jpg');
//        sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping;

//        var grassTexture = new loadImage('grass-512.jpg');
//        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        var grassTexture = new THREE.Texture(canvas1) 
        grassTexture.needsUpdate = true;
grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;

        var rockyTexture = new THREE.Texture(canvas2) 
        rockyTexture.needsUpdate = true;
rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping;

//        var rockyTexture = new loadImage('rock-512.jpg');
//        rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping;

ch = new Chromanin(256,'canvas4');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,255,255,255);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();

//        var oceanTexture = new loadImage('dirt-512.jpg');
//        oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping;
        var snowyTexture = new THREE.Texture(canvas1) 
        snowyTexture.needsUpdate = true;
snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping;

//        var snowyTexture = new loadImage('snow-512.jpg');
//        snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping;


        var TILES = 2

        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        var gmesh, water, hemiLight, light;
        var posgrass = [];
        var posgrass2 = [];
        var posgrass3 = [];
        var posgrass4 = [];
        var postrees = [];
        var controls;
        var controlsEnabled = false;
        var renderer = new THREE.WebGLRenderer({
            'precision': precision
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('3d').appendChild(renderer.domElement);
        var velocity = new THREE.Vector3();
        var onRenderFcts = [];
        var scene = new THREE.Scene();
        clock = new THREE.Clock();
        //scene.fog = new THREE.Fog(0x111111, 100, 1600);
        //    scene.fog.color.setHSL( 0.1, 0.1, 0.1 );

        scene.fog = new THREE.Fog(0x000000, 100, 3000);

        //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000000);
        var camera = new THREE.TargetCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000000);
        scene.add(camera);
       
        var onKeyDown = function(event) {

            switch (event.keyCode) {

                case 38: // up
                case 87: // w
                if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 0;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 1;

if (running ==false) {
                blendMesh.play("run", blendMesh.animations[ 'run' ].weight);
running=true;
            }}
                    moveForward = true;
                    break;

                case 37: // left
                case 65: // a
                    moveLeft = true;
                    break;

                case 40: // down
                case 83: // s
if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 0;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 1;
if (running ==false) {
                blendMesh.play("run", blendMesh.animations[ 'run' ].weight);
running=true;
            }
}
                    moveBackward = true;
                    break;

                case 39: // right
                case 68: // d
                    moveRight = true;
                    break;

                case 32: // space
                    if (canJump === true) velocity.y += 350;
                    canJump = false;
                    break;

            }

        };

        var onKeyUp = function(event) {

            switch (event.keyCode) {

                case 38: // up
                case 87: // w
if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 1;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 0;
                blendMesh.play("idle", blendMesh.animations[ 'idle' ].weight);
running=false}
                    moveForward = false;
                    break;

                case 37: // left
                case 65: // a
                    moveLeft = false;
                    break;

                case 40: // down
                case 83: // s

if (blendMesh) {
                blendMesh.animations[ 'idle' ].weight = 1;
//                blendMesh.animations[ 'walk' ].weight = 0;
                blendMesh.animations[ 'run' ].weight = 0;
                blendMesh.play("idle", blendMesh.animations[ 'idle' ].weight);
                running=false
            } 

                    moveBackward = false;
                    break;

                case 39: // right
                case 68: // d
                    moveRight = false;
                    break;

            }

        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

      
        (function() {
           
            light = new THREE.DirectionalLight('white', 0.75 * 2)
            light.position.set(-0.5, -0.5, -2)
            scene.add(light)
            hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, .5);
            scene.add(hemiLight)

        })()

        var cube
        var heightMap, mesh, geometry, material;
        setTimeout(function() {
                ld = true
            }, 5000)
           
        initSky();
    

// listen for messages from the gui
              
               

        var parameters = {
            width: 1000,
            height: 1000,
            widthSegments: 500,
            heightSegments: 500,
            depth: 1500,
            param: 1,
            filterparam: 1
        }

        var waterNormals;

ch = new Chromanin(256,'canvas5');
ch.initlayers(256,256); 
 ch.perlinNoise(0,32,185107136,256,10,1,false);  
 ch.colorLayer(3,255,255,255);
 ch.perlinNoise(0,128,9876543,256,150,8,true); 
 ch.noiseDistort(0,0,1234567,1);
  ch.embossLayer(0,0); 
  ch.addLayers(0,4,4,1,1); 
  ch.addLayers(4,2,4,0.600000023841858,1); 
  ch.addLayers(4,3,4,1,1); ch.writeCanvas();


        var waterNormals = new THREE.Texture(canvas5) 
        waterNormals.needsUpdate = true;
waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
    //    waterNormals = new THREE.ImageUtils.loadTexture('images/waternormals.jpg');
    //    waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

        water = new THREE.Water(renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 1.0,
            fog: true,
            sunDirection: light.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        });


        mirrorMesh = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(parameters.width, parameters.height),
            water.material
        );

        mirrorMesh.add(water);
        mirrorMesh.rotation.x = -Math.PI * 0.5;
        mirrorMesh.position.y = -200;
        mirrorMesh.position.x = 500;
        mirrorMesh.position.z = 500;
        mirrorMesh.scale.multiplyScalar(1)

        scene.add(mirrorMesh);

//        var worker = new Worker('/worker.js');
        
        function addTile(x, y, no) {

            if (no != true) {

                heightMap = THREEx.Terrain.allocateHeightMap(HEIGHTMAPSIZE, HEIGHTMAPSIZE)
                THREEx.Terrain.simplexHeightMap(heightMap, (HEIGHTMAPSIZE - 1) * x, (HEIGHTMAPSIZE - 1) * y)
                p = []
                p2 = []
                p3 = []
                p4 = []
                pt = []
                geometry = THREEx.Terrain.heightMapToPlaneGeometry(heightMap, x, y, p, p2, p3, p4, pt)
                gp = new THREEx.createGrassTufts(p, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS[x][y] = gp
                gp = new THREEx.createGrassTufts(p2, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS2[x][y] = gp
                gp = new THREEx.createGrassTufts(p3, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS3[x][y] = gp
                gp = new THREEx.createGrassTufts(p4, 'images/grass01.png')
                scene.add(gp)
                MAPGRASS4[x][y] = gp

                MAPTREES[x][y] = [];

                for (var i = 0; i < pt.length; i++) {
                    var r = 0// i * x * y % nature_models.length; //Math.round(Math.random()*68)
                    if (nature_models[r] != undefined) {
                        var child = nature_models[r].clone();
                        child.name = "nature_" + i;
                        child.position.set(pt[i].x, pt[i].y, pt[i].z);
                        scene.add(child);
                        child.updateMatrixWorld(true);
                        MAPTREES[x][y].push(child);
                    }
                }


                THREEx.Terrain.heightMapToVertexColor(heightMap, geometry)

                var canvas = THREEx.Terrain.heightMapToCanvas(heightMap)

                document.body.appendChild(canvas)


                var texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                var customUniforms = {
                    fogDensity: {
                        type: "f",
                        value: 0.00025
                    },
                    fogColor: {
                        type: "c",
                        value: scene.fog.color
                    },
                    fogNear: {
                        type: "f",
                        value: scene.fog.near
                    },
                    fogFar: {
                        type: "f",
                        value: scene.fog.far
                    },
                    bumpTexture: {
                        type: "t",
                        value: texture
                    },
                    bumpScale: {
                        type: "f",
                        value: 1.0
                    },
                    tcolor: {
                        type: "f",
                        value: tcolor
                    },
                    oceanTexture: {
                        type: "t",
                        value: oceanTexture
                    },
                    sandyTexture: {
                        type: "t",
                        value: sandyTexture
                    },
                    grassTexture: {
                        type: "t",
                        value: grassTexture
                    },
                    rockyTexture: {
                        type: "t",
                        value: rockyTexture
                    },
                    snowyTexture: {
                        type: "t",
                        value: snowyTexture
                    },

                };

                var material = new THREE.ShaderMaterial({
                    fog: true,
                    uniforms: customUniforms,
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                });
                mesh = new THREE.Mesh(geometry, material);
                MAPU[x][y] = material

                scene.add(mesh);
                mesh.position.x = 1000 * x + 500
                mesh.position.z = 1000 * y + 500
                mesh.scale.z = 0.01

                mesh.rotateX(-Math.PI / 2)
                mesh.scale.multiplyScalar(1000)
                MAP[x][y] = heightMap;
                MAPMESHES[x][y] = mesh;

            } else {

                //geo = new THREEx.Terrain.PlaneGeometry( 1, 1,63, 63);
                //heightMap = null//THREEx.Terrain.allocateHeightMap(64, 64)
                //THREEx.Terrain.simplexHeightMap(heightMap,63*x,63*y)

                //worker.postMessage({
                //    x: x,
                //    y: y //,geo:geo,heightMap:heightMap
                //});

                MAP[x][y] = 1;
                MAPMESHES[x][y] = 1;

            }

        }


        onRenderFcts.push(function(delta, now) {

                camera.update();
particleGroup.tick(delta)            
zt += delta/500
z=zt
                var theta = Math.PI * ( z- 0.5);
                
                scene.fog.color.r = 0.5 - z * 2
                scene.fog.color.g = 0.5 - z * 2
                scene.fog.color.b = 0.5 - z * 2

                var phi = 2 * Math.PI * (0.25 - 0.5);

                sunSphere.position.x = distance * Math.cos(phi);
                sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);

                sky.uniforms.sunPosition.value.copy(sunSphere.position);
        
if (moveForward || moveBackward || moveLeft || moveRight  )
            if ( blendMesh && blendMesh.position != undefined) {
      
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                if (moveForward) velocity.z -= 40.0 * delta * 30;
                if (moveBackward) velocity.z += 40.0 * delta * 30;

 if (blendMesh.position.y < -210) velocity.z /=2 

            //    if (moveLeft) velocity.x -= 20.0 * delta * 15;
            //    if (moveRight) velocity.x += 20.0 * delta * 15;


     bly = 0
     if (moveLeft) bly = .05
     if (moveRight) bly = -.05

 blendMesh.rotation.y += bly

                blendMesh.translateZ(velocity.z * delta);
               blendMesh.translateX(velocity.x * delta);
               
      
                



            }
            
            if (blendMesh && blendMesh.position != undefined ) {
            cx = blendMesh.position.x % 1000;
            cz = blendMesh.position.z % 1000;




            tcx = Math.floor(blendMesh.position.x / 1000);
            tcz = Math.floor(blendMesh.position.z / 1000);
            
            
            var notremove = true
            var nearbytiles = [];

            preload = 1;


            if (ld == true) {


                for (var i = tcx - TILES / 2 - preload; i <= tcx + TILES / 2 + preload; i++) {
                    for (var j = tcz - TILES / 2 - preload; j <= tcz + TILES / 2 + preload; j++) {

                        if (i >= 0 && j >= 0)
                            nearbytiles.push(i + '_' + j);
                    }
                }
                //console.log(nearbytiles);
                for (var i = 0; i < MAXTILES; i++) {
                    for (var j = 0; j < MAXTILES; j++) {

                        if (nearbytiles.indexOf(i + '_' + j) < 0 && MAP[i][j] != undefined) {

                            if (notremove != false) {
                                MAPMESHES[i][j].visible = false
                                MAPGRASS[i][j].visible = false
                                MAPGRASS2[i][j].visible = false
                                MAPGRASS3[i][j].visible = false
                                MAPGRASS4[i][j].visible = false
                                for (var k = 0; k < MAPTREES[i][j].length; k++) {
                                    MAPTREES[i][j][k].visible = false
                                }

                            } else {
                                //              console.log('NEED TO DESTROY : '+i+'_'+j)
                                scene.remove(MAPMESHES[i][j]);
                                scene.remove(MAPGRASS[i][j])
                                scene.remove(MAPGRASS2[i][j])
                                scene.remove(MAPGRASS3[i][j])
                                scene.remove(MAPGRASS4[i][j])

                                for (var k = 0; k < MAPTREES[i][j].length; k++) {
                                    scene.remove(MAPTREES[i][j][k])
                                    MAPTREES[i][j][k] = null
                                }

                                MAPMESHES[i][j].geometry.dispose();
                                MAPMESHES[i][j].material.dispose();
                                MAPMESHES[i][j] = null
                                MAP[i][j] = null;


                            }
                        }

                        if (nearbytiles.indexOf(i + '_' + j) > -1 && MAP[i][j] != undefined) {

                            if (notremove != false) {
                                MAPMESHES[i][j].visible = true
                                MAPGRASS[i][j].visible = true
                                MAPGRASS2[i][j].visible = true
                                MAPGRASS3[i][j].visible = true
                                MAPGRASS4[i][j].visible = true
                                for (var k = 0; k < MAPTREES[i][j].length; k++) {
                                    MAPTREES[i][j][k].visible = true
                                }
                            }
                        }

                        if (nearbytiles.indexOf(i + '_' + j) > -1 && MAP[i][j] == undefined) {
                            //              console.log('NEED TO CREATE :'+i+'_'+j)
                            console.log('addtile : ' + i + '' + j)
                            addTile(i, j)
                        }

                    }
                }


            }
            if (blendMesh.position.x < 1 + 1 || blendMesh.position.z < 1 + 1
            )
                blendMesh.position.y = -216.4
            else {

           

                if (ld == true) blendMesh.position.y = THREEx.Terrain.planeToHeightMapCoords(MAP[tcx][tcz], MAPMESHES[tcx][tcz], cx, cz) 
                if (blendMesh.position.y < -216.4) blendMesh.position.y = -216.4
            }

            mirrorMesh.position.x = blendMesh.position.x;
            mirrorMesh.position.z = blendMesh.position.z;
//            $('#pos').html(Math.round(blendMesh.position.x) + ' ' + Math.round(blendMesh.position.y) + ' ' + Math.round(blendMesh.position.z))


}
       })

        onRenderFcts.push(function() {
            water.material.uniforms.time.value += 1.0 / 60.0;

            water.render();
            renderer.render(scene, camera);
        })
        var lastTimeMsec = null
        requestAnimationFrame(function animate(nowMsec) {
            if (okok == true) {
if (gui != undefined) {
                     var scale = gui.getTimeScale();
                var delta = clock.getDelta();
                var stepSize = (!isFrameStepping) ? delta * scale: timeToStep;

                // modify blend weights
                if (blendMesh.skeletonHelper)
                blendMesh.update( stepSize );
                gui.update();
                THREE.AnimationHandler.update( stepSize );

}

                requestAnimationFrame(animate);
                lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
                var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
                lastTimeMsec = nowMsec
                onRenderFcts.forEach(function(onRenderFct) {
                    onRenderFct(deltaMsec / 1000, nowMsec / 1000)
                })
            }
        })


  var onMouseMove = function ( event ) {

    var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
    var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
  
  rY=event.movementX/500
  rX=-event.clientY/30+20

    if (blendMesh && blendMesh.position !=undefined) {
          
    //$('#pos2').html(rX)
      blendMesh.rotation.y -= Math.PI * rY

      settings.cameraPosition.y = -rX*3+35

      settings.cameraPosition.z = 30-rX*3
     
    }

  };

  document.addEventListener( 'mousemove', onMouseMove, false );
    </script>
            <div id="toolbar">
                <ul id="status" style="display:none;">
                    <li>
                        users:
                        <select name="users" id="usersList">
                            <option value="*">
                                all
                            </option>
                        </select>
                    </li>
                    <li>
                        name:
                        <span id="name">
                        </span>
                    </li>
                    <li>
                        room:
                        <span id="room">
                        </span>
                    </li>
                </ul>
                <input tabindex="1" type="text" id="entry" />
            </div>
        </div>
        <div id="pop">
            <div id="popHead">
                <a id="popClose" title="close">Close</a>
                <h2>
                    Tip
                </h2>
            </div>
            <div id="popContent">
                <dl>
                    <dd id="popIntro">
                    </dd>
                </dl>
                <p id="popMore">
                    No Tip Again
                </p>
            </div>
        </div>
  </div>
</div>
          
    </body>

</html>
